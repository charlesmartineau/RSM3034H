---
title: "Lecture 5:<br><span style='color:#045282'>Cross-Sectional Asset Pricing Test: Biases and Sentiment Distorting Valuation</span>"
author: "Charles Martineau"
institute: "UTSC and Rotman | [www.charlesmartineau.com](https://www.charlesmartineau.com)"
bibliography: ../lit.bib
format:
  revealjs:
    theme: default
    slide-number: true
    chalkboard: true
    incremental: false
jupyter: python3
---

## CAPM

The Capital Asset Pricing Model (CAPM) is a foundational model in finance that describes the relationship between systematic risk and expected return for stocks.

Formula:
$$E(R_i) = R_f + \beta_i (E(R_m) - R_f)$$

Where:

- $E(R_i)$: Expected return of asset \(i\)
- $R_f$: Risk-free rate
- $\beta_i$: Beta of asset \(i\) (measure of its sensitivity to market movements)
- $E(R_m)$: Expected return of the market portfolio
- $E(R_m) - R_f$: Market risk premium
- $\beta_i$ = $\frac{Cov(R_i, R_m)}{Var(R_m)}$
- Assumptions: Investors are rational, markets are efficient, and there are no taxes or transaction costs.
  
## Security Market Line (SML)
::: {style="height: 2em;"}
:::

The Security Market Line (SML) is a graphical representation of the CAPM. It plots the expected return of securities against their beta (systematic risk).

**Key properties:**


- The SML has a y-intercept equal to the risk-free rate $R_f$
- The slope of the SML equals the market risk premium $E(R_m) - R_f$
- All correctly priced assets should lie on the SML

## SML: Simulated Data

```{python}
# | echo: true
# | output: false

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Set random seed for reproducibility
np.random.seed(42)

# Define CAPM parameters
R_f = 0.01  # Risk-free rate (3%)
E_R_m = 0.07  # Expected market return (10%)
market_risk_premium = E_R_m - R_f

# Generate 10 securities with different betas
n_securities = 10
betas = np.linspace(0, 1.5, n_securities)

# Calculate expected returns based on CAPM (these will lie perfectly on SML)
expected_returns = betas * market_risk_premium + R_f

# Add small random noise to make it more realistic
noise = np.random.normal(0, 0.005, n_securities)
actual_returns = expected_returns + noise

# Create DataFrame for display
securities_df = pd.DataFrame(
    {
        "Security": [f"Stock {i + 1}" for i in range(n_securities)],
        "Beta": betas,
        "Expected Return (%)": expected_returns * 100,
        "Actual Return (%)": actual_returns * 100,
    }
)
```
## SML: Simulated Data

```{python}
#| echo: false

print("Simulated Securities Data:")
print(securities_df.round(3))
print(f"\nRisk-free rate: {R_f*100:.2f}%")
print(f"Market return: {E_R_m*100:.2f}%")
print(f"Market risk premium: {market_risk_premium*100:.2f}%")
```

## SML: Visualization

```{python}
# | echo: false
# | fig-align: center

# Plot Security Market Line
fig, ax = plt.subplots(figsize=(10, 6))

# Plot the theoretical SML
beta_line = np.linspace(0, 1.5, 100)
sml_line = beta_line * market_risk_premium + R_f
ax.plot(
    beta_line,
    sml_line * 100,
    "r-",
    linewidth=2,
    label="Security Market Line",
    alpha=0.7,
)

# Plot the individual securities
ax.scatter(
    betas,
    actual_returns * 100,
    s=100,
    alpha=0.6,
    c="blue",
    edgecolors="navy",
    linewidth=1.5,
    label="Securities",
)


# Add labels for each security
for i, (beta, ret) in enumerate(zip(betas, actual_returns)):
    ax.annotate(
        f"S{i + 1}",
        (beta, ret * 100),
        xytext=(5, 5),
        textcoords="offset points",
        fontsize=8,
        alpha=0.7,
    )

ax.set_xlabel("Beta (β)", fontsize=12, fontweight="bold")
ax.set_ylabel("Expected Return (%)", fontsize=12, fontweight="bold")
ax.set_title("Security Market Line (SML)", fontsize=14, fontweight="bold")
ax.legend(loc="upper left", fontsize=10)
ax.grid(True, alpha=0.3, linestyle="--")
ax.set_xlim(-0.1, 1.75)
ax.set_ylim(0, 12)

plt.tight_layout()
plt.show()
```

## But Does CAPM Hold Up?

Let's test the CAPM using real data: 10 beta-sorted portfolios from Kenneth French's data library.

## CAPM Test: French Beta Portfolios

```{python}
# | echo: true
# | output: false

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm

# Load Fama-French factors data (contains RF and Mkt-RF)
ff_factors = pd.read_excel("data/ff_portfolios.xlsx")
ff_factors["date"] = pd.to_datetime(ff_factors["date"], format="%Y%m")
ff_factors = ff_factors.set_index("date")

# Load 10 beta-sorted portfolios
beta_portfolios = pd.read_excel("data/ff_beta_sorted_portfolios.xlsx")
beta_portfolios["date"] = pd.to_datetime(beta_portfolios["date"], format="%Y%m")
beta_portfolios = beta_portfolios.set_index("date")

# Align dates between the two datasets
common_dates = beta_portfolios.index.intersection(ff_factors.index)
beta_portfolios = beta_portfolios.loc[common_dates]
ff_factors = ff_factors.loc[common_dates]

# Get portfolio column names (excluding date if present)
portfolio_cols = [col for col in beta_portfolios.columns if col not in ["date"]]

# Calculate betas for each portfolio using OLS regression
betas = []
for col in portfolio_cols:
    # Portfolio excess returns
    portfolio_excess = beta_portfolios[col] - ff_factors["RF"]
    market_excess = ff_factors["MKT_RF"]

    # Run OLS regression: portfolio_excess = alpha + beta * market_excess
    X = sm.add_constant(market_excess)
    model = sm.OLS(portfolio_excess, X)
    results = model.fit()
    beta = results.params[1]  # Beta is the slope coefficient
    betas.append(beta)

# Calculate average returns for each portfolio (annualized)
avg_returns = beta_portfolios[portfolio_cols].mean() * 12

# Get risk-free rate and market return (annualized)
rf_rate = ff_factors["RF"].mean() * 12
market_return = (ff_factors["MKT_RF"].mean() + ff_factors["RF"].mean()) * 12

# Create results DataFrame
results_df = pd.DataFrame(
    {
        "Portfolio": [f"Beta {i + 1}" for i in range(len(portfolio_cols))],
        "Beta": betas,
        "Avg Return (%)": avg_returns.values,
    }
)

print("Beta-Sorted Portfolios (Kenneth French Data):")
print(results_df.round(3))
print(f"\nRisk-free rate: {rf_rate:.2f}%")
print(f"Market return: {market_return:.2f}%")
print(f"Market risk premium: {(market_return - rf_rate):.2f}%")
```

## CAPM Test: Does It Hold?

```{python}
#| echo: false
#| fig-align: center

# Plot the Security Market Line with real data
fig, ax = plt.subplots(figsize=(10, 6))

# Plot theoretical SML (CAPM prediction)
beta_line = np.linspace(min(betas) - 0.1, max(betas) + 0.1, 100)
sml_line = rf_rate + beta_line * (market_return - rf_rate)
ax.plot(beta_line, sml_line, 'r-', linewidth=2, label='Theoretical SML (CAPM)', alpha=0.7)

# Fit a line through the actual portfolio data (Empirical SML)
from numpy.polynomial import Polynomial
p = Polynomial.fit(betas, avg_returns.values, 1)
empirical_sml = p(beta_line)

# Plot empirical SML (best fit line through portfolios)
ax.plot(beta_line, empirical_sml, 'g--', linewidth=2, label='Empirical SML (Best Fit)', alpha=0.7)

# Plot the actual portfolios
ax.scatter(betas, avg_returns.values, s=150, alpha=0.6, c='blue',
           edgecolors='navy', linewidth=2, label='Beta-Sorted Portfolios', zorder=5)

# Add portfolio labels
for i, (beta, ret) in enumerate(zip(betas, avg_returns.values)):
    ax.annotate(f'P{i+1}', (beta, ret), xytext=(5, 5),
                textcoords='offset points', fontsize=9, fontweight='bold')

ax.set_xlabel('Beta (β)', fontsize=12, fontweight='bold')
ax.set_ylabel('Average Annual Return (%)', fontsize=12, fontweight='bold')
ax.set_title('Security Market Line: Theory vs. Reality (1963-Present)',
             fontsize=14, fontweight='bold')
ax.legend(loc='upper left', fontsize=10)
ax.grid(True, alpha=0.3, linestyle='--')

plt.tight_layout()
plt.show()

# Calculate and display alpha for each portfolio
print("\nCAPM Prediction vs. Actual Returns:")
print("Portfolio | Beta  | Predicted Return | Actual Return | Alpha")
print("-" * 70)
for i, (beta, actual_ret) in enumerate(zip(betas, avg_returns.values)):
    predicted = rf_rate + beta * (market_return - rf_rate)
    alpha = actual_ret - predicted
    print(f"Beta {i+1:2d}   | {beta:.3f} | {predicted:6.2f}% | {actual_ret:6.2f}% | {alpha:+6.2f}%")
```

## Buy-and-Hold Returns

```{python}
#| echo: false
#| fig-align: center

# Calculate cumulative buy-and-hold returns for each portfolio
fig, ax = plt.subplots(figsize=(12, 7))

# Color palette for portfolios
colors = plt.cm.RdYlBu_r(np.linspace(0.1, 0.9, len(portfolio_cols)))

for idx, col in enumerate(portfolio_cols):
    # Calculate cumulative returns from raw returns
    cumulative_returns = (1 + beta_portfolios[col] / 100).cumprod()

    # Plot
    ax.plot(cumulative_returns.index, cumulative_returns,
            linewidth=2, label=f'Portfolio {idx+1} (β={betas[idx]:.2f})',
            color=colors[idx], alpha=0.8)

ax.set_xlabel('Date', fontsize=12, fontweight='bold')
ax.set_ylabel('Cumulative Return (%)', fontsize=12, fontweight='bold')
ax.set_title('Buy-and-Hold Returns: Beta-Sorted Portfolios',
             fontsize=14, fontweight='bold')
ax.legend(loc='best', fontsize=9, ncol=2)
ax.grid(True, alpha=0.3, linestyle='--')

plt.tight_layout()
plt.show()
```

- High-$\beta$ stocks earn less than predicted
- Low-$\beta$ stocks earn more than predicted

## Other challenges to the CAPM
::: {style="height: 2em;"}
:::

- **Fama-French Three-Factor Model**: Adds size and value factors to better explain returns.
- **Momentum Effect**: Stocks that have performed well in the past tend to continue performing well in the short term.
- **Behavioral Biases**: Investor psychology can lead to mispricings that CAPM does not account for.
- **Liquidity Risk**: Assets with lower liquidity may require higher expected returns, which CAPM does not consider.
- **Empirical Anomalies**: Various market anomalies (e.g., January effect, low-volatility anomaly) that CAPM cannot explain.

## How to test alternative asset pricing models?
::: {style="height: 2em;"}
:::

Fama-French 1993 find that size and book-to-market factors help explain the cross-section of average returns better than CAPM alone. Therefore, one should test models by including additional factors. 

$$E(R_i) = R_f + \beta_{i,MKT} (E(R_m) - R_f) + \beta_{i,SMB} E(SMB) + \beta_{i,HML} E(HML)$$

Where:

- \(SMB\): Small Minus Big (size factor)
- \(HML\): High Minus Low (value factor)

Fama-French have argued that these additional factors capture systematic risks not accounted for by CAPM.

## Anomalies

::: {style="height: 2em;"}
:::

If you find an anomaly that contradicts CAPM, you can:

1. Propose a new risk factor that explains the anomaly.
2. Argue that the anomaly is due to behavioral biases or market frictions.
3. Test the anomaly across different markets and time periods to assess its robustness.
4. Examine whether the anomaly persists after controlling for known risk factors.

How to test these explanations empirically?

- Form a long-short portfolio based on the anomaly. E.g., for the momentum anomaly, go long past winners and short past losers.
- Regress the returns of this long-short portfolio on the factors of the asset pricing model being tested.
- If the alpha (intercept) is statistically significant, it suggests that the anomaly is not fully explained by the model. 

## Testing an Anomaly: An Example

Fang and Peress (2009) find that stocks with high media coverage earn lower returns.

- Form a long-short portfolio: Long low media coverage stocks, short high media coverage stocks.

![](figures/fang.png){width=80%, .center}

What can you conclude from this regression / findings?

## Your "alpha" is it risk or mispricing?
::: {style="height: 2em;"}
:::

RISK-BASED:

- ✓ Does it covary with bad economic states?
- ✓ Is it persistent across time/markets?
- ✓ Does it capture systematic covariation?
- ✓ Can you identify the economic risk?

MISPRICING-BASED:

- ✓ Is there a behavioral bias that explains it?
- ✓ Are there limits to arbitrage?
- ✓ Does it vary with sentiment/attention?
- ✓ Is there evidence of correction over time?

## Zoo of Anomalies / Factors

Campbell R. Harvey, Yan Liu, and Heqing Zhu (2016) "...there are now more than 300 documented anomalies in the asset pricing literature."

- Is it too easy to find anomalies?
- Data mining concerns
- Publication bias
- P-hacking
- Multiple testing problem
- Lack of out-of-sample validation
- Economic significance vs. statistical significance
- Robustness across different markets and time periods
- Theoretical justification for the anomaly
- Practical implementability (transaction costs, liquidity)
- Survivorship bias in datasets

## Joint Hypothesis Problem

::: {style="height: 2em;"}
:::

Fama (1970) argued that "tests of the efficiency of markets are joint tests of the efficiency hypothesis and of a particular asset-pricing model."

**Implication:** Rejection of an asset pricing model does not necessarily imply market inefficiency; it could also indicate that the model is misspecified.

## Is the CAPM really dead?

Hasler and Martineau (2022) find that the conditional CAPM holds up well when accounting for time-varying betas and risk premia. 